* TODO Beware, by the way: early bugs will be subtle.
* TODO Test environments.
  #+BEGIN_SRC scheme :tangle test-environments.scm :shebang #!/usr/bin/env chicken-scheme
    (include "aima.scm")
  #+END_SRC
* DONE Environments
  CLOSED: [2012-06-03 Sun 03:47]
  - CLOSING NOTE [2012-06-03 Sun 03:47] \\
    This is reasonable as a proof-of-concept; we're going to imitate even
    the directory structure for now, though.
  We'll worry about utilities later; or, rather, along the way. It
  looks like [[http://wiki.call-cc.org/eggref/4/coops][coops]] is the way to go, incidentally:

  #+BEGIN_QUOTE
  05:03 < C-Keen> klutometis: coops is the new tinyclos
  #+END_QUOTE

  I toyed with the idea of getting rid of AIMA's OO; but, fuck it:
  we'll put it in. I'm aiming for a relatively shallow translation
  here; I don't necessarily want to redesign the thing.

  #+BEGIN_SRC scheme
    (use
     coops
     debug
     miscmacros
     )
    
    ;;; Environments
    
    (define-class <environment>
      (<standard-class>)
      ((agents
        initform: '()
        accessor: environment-agents)
       (step
        initform: 0
        accessor: environment-step)
       (max-steps
        initform: 1000
        accessor: environment-max-steps)
       (port
        initform: #t
        accessor: environment-port)
       (initialized?
        initform: #f
        accessor: environment-initialized?)
       (state
        initform: #f
        accessor: environment-state)))
    
    (define-class <agent>
      (<standard-class>)
      ((program
        initform: void
        accessor: agent-program)
       (body
        initform: (make-agent-body)
        accessor: agent-body)
       (score
        initform: 0
        accessor: agent-score)
       (percept
        initform: #f
        accessor: agent-percept)
       (action
        initform: #f
        accessor: agent-action)
       (name
        initform: #f
        accessor: agent-name)))
    
    (define (run-environment environment)
      (initialize environment)
      (display-environment environment)
      (call-with-current-continuation
       (lambda (return)
         (dotimes (i (environment-max-steps environment))
           (inc! (environment-step environment))
           (for-each (lambda (agent)
                       (set! (agent-percept agent)
                             (get-percept environment agent))
                       (set! (agent-action agent)
                             ;; TODO: `funcall' was here.
                             ((agent-program agent)
                              (agent-percept agent))))
             (environment-agents environment))
           (update-fn environment)
           (for-each (lambda (agent)
                       (set! (agent-score agent)
                             (performance-measure environment agent)))
             (environment-agents environment))
           (display-environment environment)
           (when (termination? environment) (return)))))
      environment)
    
    (define (agent-trials environment-fn agent-types #!key (n 10))
      (let ((env-gen-random-state (make-random-state #t)))
        (map (lambda (agent-type)
               (agent-trial environment-fn agent-type
                            (make-random-state env-gen-random-state) n)
               agent-types))))
    
    (define-method (get-percept (environment <environment>) agent) #f)
    
    (define-method (update-fn (env <environment>))
      "Modify the environment, based on agents actions, etc."
      (execute-agent-actions env))
    
    
    (define-method (legal-actions (env <environment>))
      "A list of the action operators that an agent can do."
      #f)
    
    (define-method (performance-measure (env <environment>) agent)
      "Return a number saying how well this agent is doing."
      (- (environment-step env)))
    
    ;;; Here are the ones that can usually be inherited:
    
    (define-method (initialize (env <environment>))
      "Called once to do whatever is necessary to set up the environment
      for running the simulation."
      (initialize-agent-names env)
      (set! (environment-initialized? env) t)
      env)
    
    (define-method (termination? (env <environment>))
      "Return true if the simulation should end now."
      #f)
    
    (define-method (display-environment (env <environment>))
      "Display the current state of the environment."
      ;; You probably won't need to specialize this, unless you want to do
      ;; a fancy graphical user interface
      (let ((port (environment-port env)))
        (when port 
          (format port "~&At Time step ~D:~%" (environment-step env))
          (when (> (environment-step env) 0)
                (for-each (lambda (port)
                            (format port 
                                    "~&Agent ~A perceives ~A~%~6Tand does ~A~%"
                                    agent (agent-percept agent)
                                    (agent-action agent)))
                  (environment-agents env)))
          (display-environment-snapshot env))))
    
    (define-method (display-environment-snapshot (env <environment>))
      "Display a 'picture' of the current state of the environment."
      (print env (environment-port env)))
    
    ;;;; Auxiliary Functions
    
    
  #+END_SRC
* DONE Do we really need e.g. =<stack>= instead of =stack= in =coops=?
  CLOSED: [2012-06-02 Sat 01:09]
  - CLOSING NOTE [2012-06-02 Sat 01:09] \\
    Yeah, to avoid namespace collisions with function arguments.
  #+BEGIN_SRC scheme
    (use coops
         test
         debug)
    
    (define-class <stack>
      ()
      ((data
        initform: '()
        accessor: stack-data)))
    
    (define-method (push (datum #t) (stack <stack>))
      (set! (stack-data stack)
            (cons datum (stack-data stack))))
    
    (test
     '(2 1)
     (let ((stack (make <stack>)))
       (push 1 stack)
       (push 2 stack)
       (stack-data stack)))
    
    (define (fuck-this-stack stack)
      (let ((new-stack (make <stack>)))
        (void)))
    
    (fuck-this-stack (make <stack>))
    
    (debug <stack>)
  #+END_SRC
