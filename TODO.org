* DONE Optional debugging environments.
  CLOSED: [2012-06-29 Fri 16:40]
  Can either have no-op environments that we graft in; or some other
  mechanism.

  Or, hell: instead of using the debug environments; why not have the
  classic debug-parameter that environments may or may not decide to
  use? That way, we'd have access to the agent's action as opposed to
  merely its state.
* DONE Debugging should really show what action the agent took and the state of the world.
  CLOSED: [2012-06-29 Fri 16:40]
  Not merely the e.g. agent location and score.

  What about a simple key-value debugger that produces uniform output?
* DONE Test vacuum world.
  CLOSED: [2012-06-28 Thu 11:32]
  #+BEGIN_SRC scheme :tangle test-vacuum.scm :shebang #!/usr/local/bin/chicken-scheme
    (include "aima.scm")
    (include "aima-vacuum.scm")
    (use aima aima-vacuum)
    
    (simulate-vacuum (make-world dirty clean)
                     (make-reflex-agent
                      left
                      (lambda (location clean?)
                        'right))
                     10)
  #+END_SRC
* DONE debug-environment
  CLOSED: [2012-06-28 Thu 11:32]
  . . . with e.g. =environment-print=; it's just going to be a thunk
  unless it does something special. Because we're not doing OO, we
  can't readily have a generic print which dispatches Ã  la e.g.
  =for-each= on worlds, agents, miscellaneous objects.

  What about =display=, though, with =define-record-printer=? Wow,
  maybe we should bring records back for environments; despite the
  fact that they're merely wrappers around a step-function.

  Environment is distinct from world, though; the debug function could
  have an optional display-function that defaults to =display=. That
  means, however, that we need a debug function per entity, doesn't
  it? Maybe that's no big deal.
* DONE Instead of aping the Lisp code, we should ship off on our own.
  CLOSED: [2012-06-28 Thu 11:32]
  Norvig did a wonderful thing, though: with this environment model
  and =run-environment=, he's able to cast e.g. search-problems as
  environments and run agents therein. A Chicken module might provide
  similar abstractions.
* DONE Environments
  CLOSED: [2012-06-03 Sun 03:47]
  - CLOSING NOTE [2012-06-03 Sun 03:47] \\
    This is reasonable as a proof-of-concept; we're going to imitate even
    the directory structure for now, though.
  We'll worry about utilities later; or, rather, along the way. It
  looks like [[http://wiki.call-cc.org/eggref/4/coops][coops]] is the way to go, incidentally:

  #+BEGIN_QUOTE
  05:03 < C-Keen> klutometis: coops is the new tinyclos
  #+END_QUOTE

  I toyed with the idea of getting rid of AIMA's OO; but, fuck it:
  we'll put it in. I'm aiming for a relatively shallow translation
  here; I don't necessarily want to redesign the thing.

  #+BEGIN_SRC scheme
    (use
     coops
     debug
     miscmacros
     )
    
    ;;; Environments
    
    (define-class <environment>
      (<standard-class>)
      ((agents
        initform: '()
        accessor: environment-agents)
       (step
        initform: 0
        accessor: environment-step)
       (max-steps
        initform: 1000
        accessor: environment-max-steps)
       (port
        initform: #t
        accessor: environment-port)
       (initialized?
        initform: #f
        accessor: environment-initialized?)
       (state
        initform: #f
        accessor: environment-state)))
    
    (define-class <agent>
      (<standard-class>)
      ((program
        initform: void
        accessor: agent-program)
       (body
        initform: (make-agent-body)
        accessor: agent-body)
       (score
        initform: 0
        accessor: agent-score)
       (percept
        initform: #f
        accessor: agent-percept)
       (action
        initform: #f
        accessor: agent-action)
       (name
        initform: #f
        accessor: agent-name)))
    
    (define (run-environment environment)
      (initialize environment)
      (display-environment environment)
      (call-with-current-continuation
       (lambda (return)
         (dotimes (i (environment-max-steps environment))
           (inc! (environment-step environment))
           (for-each (lambda (agent)
                       (set! (agent-percept agent)
                             (get-percept environment agent))
                       (set! (agent-action agent)
                             ;; TODO: `funcall' was here.
                             ((agent-program agent)
                              (agent-percept agent))))
             (environment-agents environment))
           (update-fn environment)
           (for-each (lambda (agent)
                       (set! (agent-score agent)
                             (performance-measure environment agent)))
             (environment-agents environment))
           (display-environment environment)
           (when (termination? environment) (return)))))
      environment)
    
    (define (agent-trials environment-fn agent-types #!key (n 10))
      (let ((env-gen-random-state (make-random-state #t)))
        (map (lambda (agent-type)
               (agent-trial environment-fn agent-type
                            (make-random-state env-gen-random-state) n)
               agent-types))))
    
    (define-method (get-percept (environment <environment>) agent) #f)
    
    (define-method (update-fn (env <environment>))
      "Modify the environment, based on agents actions, etc."
      (execute-agent-actions env))
    
    
    (define-method (legal-actions (env <environment>))
      "A list of the action operators that an agent can do."
      #f)
    
    (define-method (performance-measure (env <environment>) agent)
      "Return a number saying how well this agent is doing."
      (- (environment-step env)))
    
    ;;; Here are the ones that can usually be inherited:
    
    (define-method (initialize (env <environment>))
      "Called once to do whatever is necessary to set up the environment
      for running the simulation."
      (initialize-agent-names env)
      (set! (environment-initialized? env) t)
      env)
    
    (define-method (termination? (env <environment>))
      "Return true if the simulation should end now."
      #f)
    
    (define-method (display-environment (env <environment>))
      "Display the current state of the environment."
      ;; You probably won't need to specialize this, unless you want to do
      ;; a fancy graphical user interface
      (let ((port (environment-port env)))
        (when port 
          (format port "~&At Time step ~D:~%" (environment-step env))
          (when (> (environment-step env) 0)
                (for-each (lambda (port)
                            (format port 
                                    "~&Agent ~A perceives ~A~%~6Tand does ~A~%"
                                    agent (agent-percept agent)
                                    (agent-action agent)))
                  (environment-agents env)))
          (display-environment-snapshot env))))
    
    (define-method (display-environment-snapshot (env <environment>))
      "Display a 'picture' of the current state of the environment."
      (print env (environment-port env)))
    
    ;;;; Auxiliary Functions
    
    
  #+END_SRC
* DONE Do we really need e.g. =<stack>= instead of =stack= in =coops=?
  CLOSED: [2012-06-02 Sat 01:09]
  - CLOSING NOTE [2012-06-02 Sat 01:09] \\
    Yeah, to avoid namespace collisions with function arguments.
  #+BEGIN_SRC scheme
    (use coops
         test
         debug)
    
    (define-class <stack>
      ()
      ((data
        initform: '()
        accessor: stack-data)))
    
    (define-method (push (datum #t) (stack <stack>))
      (set! (stack-data stack)
            (cons datum (stack-data stack))))
    
    (test
     '(2 1)
     (let ((stack (make <stack>)))
       (push 1 stack)
       (push 2 stack)
       (stack-data stack)))
    
    (define (fuck-this-stack stack)
      (let ((new-stack (make <stack>)))
        (void)))
    
    (fuck-this-stack (make <stack>))
    
    (debug <stack>)
  #+END_SRC
* CANCELED sample-with-replacement
  CLOSED: [2012-06-28 Thu 11:32]
  #+BEGIN_SRC scheme
    (use
     debug
     (prefix random-bsd random-bsd:)
     srfi-1
     )
    
    (define (random-integer from to)
      "Return an integer chosen at random from the given interval."
      ;; Appears to be an off-by-one here:
      ;; (+ from (random-bsd:random-integer (+ 1 (- to from))))
      (+ from (random-bsd:random-integer (- to from))))
    
    (define (random-element list)
      "Return some element of the list, chosen at random."
      (list-ref list (random-integer 0 (length list))))
    
    (define (sample-with-replacement n population)
      (unfold (lambda (i)
                (debug (> i n))
                (> i n))
              (lambda (i)
                (debug (random-element population)
                       population)
                (random-element population))
              add1
              1))
    
    (sample-with-replacement 10 '(1 2 3))
  #+END_SRC
* CANCELED Try [[http://srfi.schemers.org/srfi-17/srfi-17.html][srfi-17]] for =defsetf=.
  CLOSED: [2012-06-28 Thu 11:32]
* CANCELED Beware, by the way: early bugs will be subtle.
  CLOSED: [2012-06-28 Thu 11:33]
* CANCELED Test environments.
  CLOSED: [2012-06-28 Thu 11:33]
  #+BEGIN_SRC scheme :tangle test-environments.scm :shebang #!/usr/bin/env chicken-scheme
    (include "aima.scm")
  #+END_SRC
