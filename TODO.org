* TODO Environments
  We'll worry about utilities later; or, rather, along the way. It
  looks like [[http://wiki.call-cc.org/eggref/4/coops][coops]] is the way to go, incidentally:

  #+BEGIN_QUOTE
  05:03 < C-Keen> klutometis: coops is the new tinyclos
  #+END_QUOTE

  I toyed with the idea of getting rid of AIMA's OO; but, fuck it:
  we'll put it in. I'm aiming for a relatively shallow translation
  here; I don't necessarily want to redesign the thing.

  #+BEGIN_SRC scheme
    (use
     coops
     debug
     miscmacros
     )
    
    ;;; Environments
    
    (define-class <environment>
      (<standard-class>)
      ((agents
        initform: '()
        accessor: environment-agents)
       (step
        initform: 0
        accessor: environment-step)
       (max-steps
        initform: 1000
        accessor: environment-max-steps)
       (port
        initform: #t
        accessor: environment-port)
       (initialized?
        initform: #f
        accessor: environment-initialized?)
       (state
        initform: #f
        accessor: environment-state)))
    
    (define-class <agent>
      (<standard-class>)
      ((program
        initform: void
        accessor: agent-program)
       (body
        initform: (make-agent-body)
        accessor: agent-body)
       (score
        initform: 0
        accessor: agent-score)
       (percept
        initform: #f
        accessor: agent-percept)
       (action
        initform: #f
        accessor: agent-action)
       (name
        initform: #f
        accessor: agent-name)))
    
    (define (run-environment environment)
      (initialize environment)
      (display-environment environment)
      (call-with-current-continuation
       (lambda (return)
         (dotimes (i (environment-max-steps environment))
           (inc! (environment-step environment))
           (for-each (lambda (agent)
                       (set! (agent-percept agent)
                             (get-percept environment agent))
                       (set! (agent-action agent)
                             (apply
                              (agent-program agent)
                              (agent-percept agent))))
             (environment-agents environment))
           (update-fn environment)
           (for-each (lambda (agent)
                       (set! (agent-score agent)
                             (performance-measure environment agent)))
             (environment-agents environment))
           (display-environment environment)
           (when (termination? environment) (return)))))
      environment)
    
    (define (agent-trials environment-fn agent-types #!key (n 10))
      (let ((env-gen-random-state (make-random-state #t)))
        (map (lambda (agent-type)
               (agent-trial environment-fn agent-type
                            (make-random-state env-gen-random-state) n)
               agent-types))))
    
    ()
  #+END_SRC
* DONE Do we really need e.g. =<stack>= instead of =stack= in =coops=?
  CLOSED: [2012-06-02 Sat 01:09]
  - CLOSING NOTE [2012-06-02 Sat 01:09] \\
    Yeah, to avoid namespace collisions with function arguments.
  #+BEGIN_SRC scheme
    (use coops
         test
         debug)
    
    (define-class <stack>
      ()
      ((data
        initform: '()
        accessor: stack-data)))
    
    (define-method (push (datum #t) (stack <stack>))
      (set! (stack-data stack)
            (cons datum (stack-data stack))))
    
    (test
     '(2 1)
     (let ((stack (make <stack>)))
       (push 1 stack)
       (push 2 stack)
       (stack-data stack)))
    
    (define (fuck-this-stack stack)
      (let ((new-stack (make <stack>)))
        (void)))
    
    (fuck-this-stack (make <stack>))
    
    (debug <stack>)
  #+END_SRC
