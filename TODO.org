* TODO Documentation!
  How should we do this: roll our own with org/html/latex, or use the
  chicken wiki? Some eggs are merely pointers to the "real" docs.

  Would be nice to have something R-like: autodocs for the
  public-facing functions (some S-expression-based intermediate that
  goes to latex/html?); a hand-crafted vignette for HOWTO.

  If we use docstrings, we can co√∂pt the reader; do we have to deal
  specially with things like =case-lambda=, parameters, scalars and
  procedures (both of the =define= and naked lambda flavors)?

  Should we check out what [[http://docs.racket-lang.org/scribble/][scribble]] has to say? Is it time to
  resurrect [[http://www.cs.tufts.edu/~nr/noweb/][noweb]]?

  What about the language in the docstrings: latex, html, groff,
  markdown, docbook, restructured-text; any, all? Isn't it also
  uncomfortable to edit those sorts of things in strings without any
  editor support?

  Would it make sense, therefore, to have a documentation macro?

  Can the documentation itself be a Scheme structure along the lines
  of:

  #+BEGIN_SRC scheme :tangle doc.scm
    (use debug
         define-record-and-printer
         lolevel
         matchable
         regex
         srfi-1
         srfi-13
         srfi-69
         stack)
    
    (import-for-syntax matchable)
    
    ;;; If we encounter a symbol, by the way, should give it back
    ;;; verbatim.
    (set-read-syntax! #\@ (lambda (in) (read in) (values)))
    
    @(title "Foo a bar in fixnum days.")
    @(author "Harro Freunds")
    @(email "harro@freunds.com")
    @(heading "The baz of quux")
    
    (define (foo bar #!optional baz #!rest quux)
      @("Foo a bar."
        "An optional and more thorough explanation involving fooing bars;
    what this really entails; pre- or post-conditions; &c."
        (bar "The bar to be foo'd")
        (baz "Some optional baz")
        (quux "The rest")
        ;; Can't have a parameter named `return', though; should use
        ;; `@return'; or `@<keyword>' in general for keywords?
        ;; `<keywords>:' such as: `return:', `rest:'. `markup: {latex,
        ;; html, groff, markdown, docbook}' is interesting.
        "A foo'd bar")
      bar)
    
    (debug (foo 2))
    
    (define all-your-base
      @("Your base belong thither; don't fight it.")
      'belong-thither)
    
    (define (nullary-procedure)
      @("Nullary procedures take no parameters.")
      2 2 3 3)
    
    (define nullary-lambda
      @("Nullary procedures take no parameters.")
      (lambda () 2 2 3 3))
    
    (define current-docexpr
      @("Enables communication with the parsing @-reader")
      (make-parameter #f))
    
    (define (with-new-doctable thunk)
      (parameterize ((current-doctable (make-hash-table)))
        (thunk)))
    
    ;;; Without an explicit return or description keyword (or other),
    ;;; can't distinguish the last description from the return value
    ;;; (which is optional, by the way).
    ;;;
    ;;; Some other structure for short and long descriptions: a list?
    (define test-case-lambda
      @("Just testing case-lambda"
        "We're mapping arbitrary arguments to arbitrary integers."
        (a "An argument")
        (b "Some other argument")
        (c "The rest arguments")
        "An integer")
      (case-lambda
       (() 2)
       ((a) 3)
       ((a b) 4)
       ((a b . c) 5)))
    
     (define-syntax debug
       @("Testing the syntax")
       (syntax-rules ()
         ((_ x ...)
          (with-output-to-port
              (current-error-port)
            (lambda ()
              (pp `((x ,x) ...)))))))
    
    (define docexprs (make-parameter (make-stack)))
    
    (define-record-and-printer null-expression)
    (define null-expression (make-null-expression))
    
    (set-read-syntax! #\@
      (lambda (in)
        (current-docexpr (read in))
        (stack-push! (docexprs) (make-docexpr (current-docexpr) null-expression))
        (values)))
    
    (define-record-and-printer docexpr
      doc
      expression)
    
    (with-input-from-file "doc.scm"
      (lambda ()
        (do ((expression (read) (read)))
            ((eof-object? expression))
          (if (current-docexpr)
              (docexpr-expression-set! (stack-peek (docexprs)) expression))
          (current-docexpr #f))))
    
    ;;; TODO: parameter, syntax, case-lambda?
    (define-record-and-printer directive
      name
      parameters)
    
    (define-record-and-printer procedure
      name
      formals)
    
    (define-record-and-printer scalar
      name)
    
    (define-record-and-printer parameter
      name)
    
    (define-record-and-printer case-lambda
      name
      formals+)
    
    (define-record-and-printer syntax
      name)
    
    (define (parse-directive doc)
      (make-directive (car doc) (cdr doc)))
    
    (define (parse-procedure name formals)
      (make-procedure name formals))
    
    (define (parse-scalar name)
      (make-scalar name))
    
    (define (parse-parameter name)
      (make-parameter name))
    
    (define (parse-case-lambda name formals+)
      (make-case-lambda name formals+))
    
    (define (parse-syntax keyword)
      (make-syntax keyword))
    
    (define (parse-docexpr docexpr)
      (match (docexpr-expression docexpr)
        ((? null-expression?)
         (parse-directive (docexpr-doc docexpr)))
        (('define (procedure . formals) . body)
         (parse-procedure procedure formals))
        (('define procedure ('lambda formals . body))
         (parse-procedure procedure formals))
        (('define procedure ('case-lambda (formals . body) ...))
         (parse-case-lambda procedure formals))
        (('define parameter ('make-parameter init . converter))
         (parse-parameter parameter))
        (('define scalar . body)
         (parse-scalar scalar))
        (('define-syntax keyword . _)
         (parse-syntax keyword))
        (_ 'unknown)))
    
    ;; (debug (stack->list (docexprs)))
    
    (debug
     (stack->list
      (do ((parsed-docexprs (make-stack))
           (docexpr (stack-pop! (docexprs)) (stack-pop! (docexprs))))
          ((stack-empty? (docexprs)) parsed-docexprs)
        (stack-push! parsed-docexprs (parse-docexpr docexpr)))))
    
  #+END_SRC

  It would be nice to parse the signature from the definition; we're
  going to have to understand e.g. keywords, rest and optional
  parameters, then.

  Would be nice to have a link to the purged source, too (i.e. sans
  docs).

  If you load the module doc,

  See [[http://www.metapaper.net/lisovsky/ad/mole/][mole]] and [[http://wiki.call-cc.org/eggref/4/contracts][contracts]], by the way. The reader-macro should no-op on
  the docs when the code is compiled; there will be a separate reading
  step, I take it, when we generate the docs.

  Start with support for latex; generalize this later? Would be nice
  to generate wiki, too. I think we can even pre-post-order the
  doc-expr, can't we? Meh; let's just iterate over it: populating an
  e.g. hash-table.

  How is that reader going to work: iterates over top-level forms;
  recursively descending into it for an instance of a doc-expr? In
  which case: I wonder if we can have two packages, doc with a @-noop
  and doc-parser with a @-parser. The latter is called from the
  binary; the former is included in code.

  I wonder if each code block could operate on some hash-table
  parameter (e.g. =current-doc-table=), referenced by
  =set-read-syntax!=.

  That way, we don't have to identify @-exprs: we simply descend
  readingly and the read-syntax takes care of the rest. Say we wanted
  to use a doc-form (i.e. =(doc "Description" (foo "Bar") ...)=)
  instead; could we simply define a relevant doc-macro? We'd have to
  eval the contents, though, which I'd like to avoid.

  So we descend readingly, populate the doc-table for that expression;
  now what? Can we identify whether we're dealing with a scalar,
  parameter, procedure or case-lambda? In cases where this is obscured
  by e.g. a surrounding =let=, can we give a hint via =procedure:=,
  =scalar:=, =parameter:= hints? Also, do we special-case modules for
  the cats that don't separate module-definitions from
  implementations? Is there a way to figure out which forms are
  exported from a module and only include those, unless we have an
  =export:= hint?

  We'd have to have first-class support for modules, probably; would
  this also entail descending into =includes=? What about module-less
  code?

  That whole first-sentence as overview, second as detailed
  description thing is current; should we go with it?

  If we iterate through the doc-expr, why not a data-directed dispatch
  an e.g. string, symbol and pair; and thence a data-directed dispatch
  on =(car pair)=?

  Is there a latex package, by the way, for typesetting docs? Looks
  like we might be [[http://stackoverflow.com/questions/501241/can-latex-be-used-for-producing-any-documentation-that-accompanies-software][on our own]].

  For listings, try [[http://www.ctan.org/tex-archive/macros/latex/contrib/minted/][minted]]; maybe there can be a source section at the
  end of the document? Will this make sense without the unexported
  functions? Can we list the whole fucking thing and selectively
  hyper-ref in there? Let's try.

  Let's document top-level forms for now; becoming module-aware later.
  This decision has the side-effect that module-definitions will have
  to be separated from implementations. Maybe that's not a bad thing
  (cf. etags).

  On the other hand, Pygments is pretty garish; also, how are we going
  to link in without line-numbers or other? Hmm: =minted= provides
  =listing=; provided that we don't want to list the entire file.

  If we take Moritz Heidkamp's suggestion, incidentally, and use a
  =doc= macro instead of the =@= reader-macro . . . lost my thought.

  #+BEGIN_SRC tex :tangle doc.tex
    \documentclass{article}
    \usepackage{fontspec}
    \usepackage{amsmath}
    \usepackage{tabularx}
    \usepackage{minted}
    \usemintedstyle{borland}
    \usepackage[xetex,
      pdfborder=0 0 0,
      colorlinks,
      linkcolor=blue,
      citecolor=blue,
      urlcolor=blue]{hyperref}
    \usepackage{caption}
    \DeclareCaptionType{source}[Source][List of sources]
    \renewenvironment{source}{}{}
    \usepackage{capt-of}
    \title{Foo a bar in fixnum days.}
    \author{Harro Freunds
      \texttt{<}\href{mailto:harro@freunds.com}
           {\nolinkurl{harro@freunds.com}}\texttt{>}}
    \begin{document}
    \maketitle
    \tableofcontents
    \section{\texttt{foo}}
    \begin{description}
      \item[Procedure] \texttt{(foo \emph{bar \#!optional baz \#!rest quux}) $\to$ A foo'd bar}
      \item[Description] Foo a bar.
    
        An optional and more thorough explanation involving fooing bars;
        what this really entails; pre- or post-conditions; \&c.
      \item[Parameters]
        \begin{tabularx}{\textwidth}[t]{lX}
          \texttt{bar} & The bar to be foo'd \\
          \texttt{baz} & Some optional baz \\
          \texttt{quux} & The rest
        \end{tabularx}
    \end{description}
    \begin{source}
      \begin{minted}[linenos]{scheme}
    (define (foo bar #!optional baz #!rest quux)
      (if baz (baz quux))
      bar)
      \end{minted}
      \label{foo}
    \end{source}
    \section{\texttt{test-case-lambda}}
    \begin{description}
    \item[Procedure] 
      \begin{tabular}[t]{lcl}
          \texttt{(test-case-lambda)} & $\to$ & \texttt{baz} \\
          \texttt{(test-case-lambda \emph{a})} & $\to$ & \texttt{baz} \\
          \texttt{(test-case-lambda \emph{a b})} & $\to$ & \texttt{baz} \\
          \texttt{(test-case-lambda \emph{a b . c})} & $\to$ & \texttt{baz}
      \end{tabular}
    \item[Description] Test case-lambda.
    
      We're mapping arbitrary arguments to arbitrary integers: we have
      medadic, monadic, dyadic and polyadic formals.
    \item[Parameters]
      \begin{tabularx}{\linewidth}[t]{lX}
        a & An argument \\
        b & Some other argument \\
        c & The rest arguments
      \end{tabularx}
    \end{description}
    \begin{source}
    \begin{minted}[linenos]{scheme}
    (define test-case-lambda
      (case-lambda
       (() 2)
       ((a) 3)
       ((a b) 4)
       ((a b . c) 5)))
    \end{minted}
    \label{test-case-lambda}
    \end{source}
    \end{document}
    
  #+END_SRC

  Let's model the latex style after SRFIs; take [[http://srfi.schemers.org/srfi-1/srfi-1.html][SRFI-1]], for example:
  it has an abstract, rationale, &c. Can we just provide e.g. sections
  and arbitrary blocks of latex-formatted string? Sure. Or, how about
  =@(text ...)= blocks? How do we document such things in the
  self-same system? We can't!

  Do be able to do something like =cons* elt_1 elt_2 ...= or
  =make-list n [fill]= we're going to have to parse the parameter
  list; can we fake it, somehow? Also, there's a mapping to the type:
  =cons* elt_1 elt_2 ... -> object=.

  Should we formalize examples √° la the following?

  #+BEGIN_EXAMPLE
    (cons 'a '())        => (a)
    (cons '(a) '(b c d)) => ((a) b c d)
    (cons "a" '(b c))    => ("a" b c)
    (cons 'a 3)          => (a . 3)
    (cons '(a b) 'c)     => ((a b) . c)
  #+END_EXAMPLE

  According to [[http://srfi.schemers.org/srfi-69/srfi-69.html][srfi-69]], =undefined= is the result of void; srfi-69
  also uses legitimate arrows. It also prefixes things with
  ``Procedure:''; can we do the same for parameters, macros, scalars?

  This is an interesting artifact:

  #+BEGIN_QUOTE
  Procedure: alist->hash-table alist [ equal? [ hash [ args ‚Ä¶ ]]] ‚Üí hash-table
  #+END_QUOTE

  Procedure name is in roman; args are in italics; witness the nested
  brackets. Examples done over a math-array would be cool: aligned
  over the assignment operator.

  Others, like [[http://srfi.schemers.org/srfi-11/srfi-11.html][srfi-11]], specify procedures with angle-bracket-wrapped
  parameters:

  #+BEGIN_EXAMPLE
    (LET-VALUES ((<formals> <expression>) ...) <body>)
  #+END_EXAMPLE

  See [[http://srfi.schemers.org/srfi-13/srfi-13.html][srfi-13]]: yeah, let's go Olin Shivers style. Formal semantics,
  syntax, &c.? Not for now.

  #+BEGIN_SRC scheme
    (define (harro freunds)
      @("Say `harro' to freunds."
        (example (harro 'wirklich) "yes")
        (example (harro 'freunds) "jein")))
  #+END_SRC

  Special support for abstracts? See [[http://tex.stackexchange.com/questions/55922/name-a-section-in-latex-toc-add-subtitle-to-contentsline][subtitles in TOC]].

  Eventually, we want to pull all of the metadata out of =<egg>.meta=,
  or even populate the meta-file on the basis of e.g.
  =use=-statements. For now, though, we'll specify them with top-level
  forms.

  Damn: if we use the =listing= environment; we can have a
  =listoflistings=. Multipage listings are awkward, though: see [[http://tex.stackexchange.com/questions/12428/code-spanning-over-two-pages-with-minted-inside-listing-with-caption][this]],
  where they recommend using the =caption= package. Also [[http://tex.stackexchange.com/questions/7210/label-and-caption-without-float][this]], which
  is a more generic solution.
** TODO =case-lambda=
   We might have to have separate =docexprs= for every arm of the
   case-lambda: ouch.

   Or can we simply have unified parameter-docs with optional
   defaults?
** TODO Syntax
   Expand the syntax, then parse it; along the way, figure out what
   the fuck it is when expanded.

   Even =expand*= doesn't help decipher it; might just have to list it
   as something opaque: or provide a =formals= parameter?

   R5RS calls it [[http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_idx_118][library syntax]]; let's use R5RS as the target: it has
   support for examples which align on \Rightarrow, &c.

   It also has e.g.:

   #+BEGIN_QUOTE
   _library-syntax_: =(or <test_1> ...)=
   #+END_QUOTE

   where =<test_1>= is in italics (but only sometimes).
** TODO Line-numbers
   Is [[http://wiki.call-cc.org/man/4/Unit%2520expand#get-line-number][get-line-number]] useful? Only for compiled code, though.
** TODO Examples
** TODO SRFI vs. R5RS style
   Let's go with R5RS; cool stuff, like syntax vs. semantics. Oh, wow:
   in the case of [[http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.2.6][quasiquotation]], they simply repeated the =syntax:=
   lines. We could also just use nested =[]=, but the formals for
   case-lambda need not be subsets of each other.
** TODO Forms that are unrecognizable.
   Macros, let-over-lambda; let's add some mechanism to override the
   parser.
** TODO =parse-docexprs= should be extensible.
** TODO Refer to other expressions in the same document with e.g. =\ref{foo}=.
** TODO Order them differently than they appear in the source code?
   Alphabetically, like R; or: according to conceptual groups
   (preferable)?
** TODO There's a disparity between what characters TeX and Scheme allow.
   This may bite us in things like labels; certainly, some escaping
   will have to take place.
* TODO Allow specifying agent programs for graph agents.
* TODO Disguise hash-table operations in graph-world.
* TODO Need to distinguish betwee world and graph-world in vacuum.
* TODO =aima-vacuum= as a module that exposes =vacuum-two-square= and =vacuum-graph=
* TODO When agent return =#<undefined>=, there is an infinite loop.
* TODO Screencast on how to do a simple reflex agent.
* TODO One final debug output after last action.
* DONE Optional debugging environments.
  CLOSED: [2012-06-29 Fri 16:40]
  Can either have no-op environments that we graft in; or some other
  mechanism.

  Or, hell: instead of using the debug environments; why not have the
  classic debug-parameter that environments may or may not decide to
  use? That way, we'd have access to the agent's action as opposed to
  merely its state.
* DONE Debugging should really show what action the agent took and the state of the world.
  CLOSED: [2012-06-29 Fri 16:40]
  Not merely the e.g. agent location and score.

  What about a simple key-value debugger that produces uniform output?
* DONE Test vacuum world.
  CLOSED: [2012-06-28 Thu 11:32]
  #+BEGIN_SRC scheme :tangle test-vacuum.scm :shebang #!/usr/local/bin/chicken-scheme
    (include "aima.scm")
    (include "aima-vacuum.scm")
    (use aima aima-vacuum)
    
    (simulate-vacuum (make-world dirty clean)
                     (make-reflex-agent
                      left
                      (lambda (location clean?)
                        'right))
                     10)
  #+END_SRC
* DONE debug-environment
  CLOSED: [2012-06-28 Thu 11:32]
  . . . with e.g. =environment-print=; it's just going to be a thunk
  unless it does something special. Because we're not doing OO, we
  can't readily have a generic print which dispatches √† la e.g.
  =for-each= on worlds, agents, miscellaneous objects.

  What about =display=, though, with =define-record-printer=? Wow,
  maybe we should bring records back for environments; despite the
  fact that they're merely wrappers around a step-function.

  Environment is distinct from world, though; the debug function could
  have an optional display-function that defaults to =display=. That
  means, however, that we need a debug function per entity, doesn't
  it? Maybe that's no big deal.
* DONE Instead of aping the Lisp code, we should ship off on our own.
  CLOSED: [2012-06-28 Thu 11:32]
  Norvig did a wonderful thing, though: with this environment model
  and =run-environment=, he's able to cast e.g. search-problems as
  environments and run agents therein. A Chicken module might provide
  similar abstractions.
* DONE Environments
  CLOSED: [2012-06-03 Sun 03:47]
  - CLOSING NOTE [2012-06-03 Sun 03:47] \\
    This is reasonable as a proof-of-concept; we're going to imitate even
    the directory structure for now, though.
  We'll worry about utilities later; or, rather, along the way. It
  looks like [[http://wiki.call-cc.org/eggref/4/coops][coops]] is the way to go, incidentally:

  #+BEGIN_QUOTE
  05:03 < C-Keen> klutometis: coops is the new tinyclos
  #+END_QUOTE

  I toyed with the idea of getting rid of AIMA's OO; but, fuck it:
  we'll put it in. I'm aiming for a relatively shallow translation
  here; I don't necessarily want to redesign the thing.

  #+BEGIN_SRC scheme
    (use
     coops
     debug
     miscmacros
     )
    
    ;;; Environments
    
    (define-class <environment>
      (<standard-class>)
      ((agents
        initform: '()
        accessor: environment-agents)
       (step
        initform: 0
        accessor: environment-step)
       (max-steps
        initform: 1000
        accessor: environment-max-steps)
       (port
        initform: #t
        accessor: environment-port)
       (initialized?
        initform: #f
        accessor: environment-initialized?)
       (state
        initform: #f
        accessor: environment-state)))
    
    (define-class <agent>
      (<standard-class>)
      ((program
        initform: void
        accessor: agent-program)
       (body
        initform: (make-agent-body)
        accessor: agent-body)
       (score
        initform: 0
        accessor: agent-score)
       (percept
        initform: #f
        accessor: agent-percept)
       (action
        initform: #f
        accessor: agent-action)
       (name
        initform: #f
        accessor: agent-name)))
    
    (define (run-environment environment)
      (initialize environment)
      (display-environment environment)
      (call-with-current-continuation
       (lambda (return)
         (dotimes (i (environment-max-steps environment))
           (inc! (environment-step environment))
           (for-each (lambda (agent)
                       (set! (agent-percept agent)
                             (get-percept environment agent))
                       (set! (agent-action agent)
                             ;; TODO: `funcall' was here.
                             ((agent-program agent)
                              (agent-percept agent))))
             (environment-agents environment))
           (update-fn environment)
           (for-each (lambda (agent)
                       (set! (agent-score agent)
                             (performance-measure environment agent)))
             (environment-agents environment))
           (display-environment environment)
           (when (termination? environment) (return)))))
      environment)
    
    (define (agent-trials environment-fn agent-types #!key (n 10))
      (let ((env-gen-random-state (make-random-state #t)))
        (map (lambda (agent-type)
               (agent-trial environment-fn agent-type
                            (make-random-state env-gen-random-state) n)
               agent-types))))
    
    (define-method (get-percept (environment <environment>) agent) #f)
    
    (define-method (update-fn (env <environment>))
      "Modify the environment, based on agents actions, etc."
      (execute-agent-actions env))
    
    
    (define-method (legal-actions (env <environment>))
      "A list of the action operators that an agent can do."
      #f)
    
    (define-method (performance-measure (env <environment>) agent)
      "Return a number saying how well this agent is doing."
      (- (environment-step env)))
    
    ;;; Here are the ones that can usually be inherited:
    
    (define-method (initialize (env <environment>))
      "Called once to do whatever is necessary to set up the environment
      for running the simulation."
      (initialize-agent-names env)
      (set! (environment-initialized? env) t)
      env)
    
    (define-method (termination? (env <environment>))
      "Return true if the simulation should end now."
      #f)
    
    (define-method (display-environment (env <environment>))
      "Display the current state of the environment."
      ;; You probably won't need to specialize this, unless you want to do
      ;; a fancy graphical user interface
      (let ((port (environment-port env)))
        (when port 
          (format port "~&At Time step ~D:~%" (environment-step env))
          (when (> (environment-step env) 0)
                (for-each (lambda (port)
                            (format port 
                                    "~&Agent ~A perceives ~A~%~6Tand does ~A~%"
                                    agent (agent-percept agent)
                                    (agent-action agent)))
                  (environment-agents env)))
          (display-environment-snapshot env))))
    
    (define-method (display-environment-snapshot (env <environment>))
      "Display a 'picture' of the current state of the environment."
      (print env (environment-port env)))
    
    ;;;; Auxiliary Functions
    
    
  #+END_SRC
* DONE Do we really need e.g. =<stack>= instead of =stack= in =coops=?
  CLOSED: [2012-06-02 Sat 01:09]
  - CLOSING NOTE [2012-06-02 Sat 01:09] \\
    Yeah, to avoid namespace collisions with function arguments.
  #+BEGIN_SRC scheme
    (use coops
         test
         debug)
    
    (define-class <stack>
      ()
      ((data
        initform: '()
        accessor: stack-data)))
    
    (define-method (push (datum #t) (stack <stack>))
      (set! (stack-data stack)
            (cons datum (stack-data stack))))
    
    (test
     '(2 1)
     (let ((stack (make <stack>)))
       (push 1 stack)
       (push 2 stack)
       (stack-data stack)))
    
    (define (fuck-this-stack stack)
      (let ((new-stack (make <stack>)))
        (void)))
    
    (fuck-this-stack (make <stack>))
    
    (debug <stack>)
  #+END_SRC
* CANCELED sample-with-replacement
  CLOSED: [2012-06-28 Thu 11:32]
  #+BEGIN_SRC scheme
    (use
     debug
     (prefix random-bsd random-bsd:)
     srfi-1
     )
    
    (define (random-integer from to)
      "Return an integer chosen at random from the given interval."
      ;; Appears to be an off-by-one here:
      ;; (+ from (random-bsd:random-integer (+ 1 (- to from))))
      (+ from (random-bsd:random-integer (- to from))))
    
    (define (random-element list)
      "Return some element of the list, chosen at random."
      (list-ref list (random-integer 0 (length list))))
    
    (define (sample-with-replacement n population)
      (unfold (lambda (i)
                (debug (> i n))
                (> i n))
              (lambda (i)
                (debug (random-element population)
                       population)
                (random-element population))
              add1
              1))
    
    (sample-with-replacement 10 '(1 2 3))
  #+END_SRC
* CANCELED Try [[http://srfi.schemers.org/srfi-17/srfi-17.html][srfi-17]] for =defsetf=.
  CLOSED: [2012-06-28 Thu 11:32]
* CANCELED Beware, by the way: early bugs will be subtle.
  CLOSED: [2012-06-28 Thu 11:33]
* CANCELED Test environments.
  CLOSED: [2012-06-28 Thu 11:33]
  #+BEGIN_SRC scheme :tangle test-environments.scm :shebang #!/usr/bin/env chicken-scheme
    (include "aima.scm")
  #+END_SRC
